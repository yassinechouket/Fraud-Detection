ğŸŸ¢ Stage 1: Build the JAR
FROM maven:3.9.9-eclipse-temurin-21-alpine AS build


Base image: maven:3.9.9-eclipse-temurin-21-alpine
â†’ This is a Maven + Java 21 + Alpine Linux image.

It has Maven installed, so we can compile Java code and build the .jar.

Example:
If you run docker run -it maven:3.9.9-eclipse-temurin-21-alpine mvn -v, it prints the Maven version.

WORKDIR /app


Set the containerâ€™s working directory to /app.

Every future command runs inside /app.

COPY pom.xml .
RUN mvn dependency:go-offline


Copy pom.xml (just the project dependencies file) into the container.

Run mvn dependency:go-offline â†’ downloads all the dependencies listed in pom.xml.

Why?: This creates a cache layer. So next time you rebuild, if pom.xml didnâ€™t change, Docker wonâ€™t redownload everything.

Example:
If your app uses Spring Boot 3.2.5, it will download jars like:
spring-boot-starter-web-3.2.5.jar, spring-boot-starter-data-mongodb-3.2.5.jar, etc.

COPY src ./src


Copy your source code into the container.

So now /app inside the container looks like:

/app
  â”œâ”€â”€ pom.xml
  â””â”€â”€ src/
       â”œâ”€â”€ main/java/com/example/...
       â””â”€â”€ main/resources/application.properties

RUN mvn clean package -DskipTests


Compile the project and build a fat JAR (includes your code + dependencies + resources).

-DskipTests skips running unit tests to save build time.

Example:
This generates:

/app/target/real-time-fraud-detection-0.0.1-SNAPSHOT.jar

ğŸŸ¢ Stage 2: Runtime container
FROM alpine:latest


Start a fresh, tiny Alpine Linux image.

This has no Maven, no compiler â†’ only what we explicitly install.

ENV JAVA_HOME=/usr/lib/jvm/java-21-openjdk
ENV PATH="$JAVA_HOME/bin:${PATH}"
ENV DOCKERIZE_VERSION=v0.9.3


Define environment variables:

JAVA_HOME â†’ where Java will be installed.

Update PATH so the java command is available.

Set the version of dockerize we want to install.

RUN apk update --no-cache \
    && apk add --no-cache openjdk21 wget bash \
    && wget -O - https://github.com/jwilder/dockerize/releases/download/$DOCKERIZE_VERSION/dockerize-alpine-linux-amd64-$DOCKERIZE_VERSION.tar.gz \
       | tar xzf - -C /usr/local/bin \
    && apk del wget


apk = Alpineâ€™s package manager.

Install:

openjdk21 â†’ Java Runtime (needed to run the JAR).

wget â†’ temporary tool to download files.

bash â†’ shell.

Download and install dockerize (a tool that waits for services like MongoDB/Postgres before starting the app).

Remove wget after install â†’ keep image small.

Example:
If MongoDB is not ready yet, you can run:

dockerize -wait tcp://mongo:27017 -timeout 30s java -jar app.jar


This waits up to 30s until MongoDB is up before starting your app.

WORKDIR /app


Switch to /app again in the runtime image.

COPY --from=build /app/target/*.jar app.jar


Copy the fat JAR built in stage 1 into this runtime image.

Now /app/app.jar is your application.

EXPOSE 8080


Tells Docker that the app listens on port 8080.

(This doesnâ€™t open the port itself, but helps documentation and tools like docker run -p 8080:8080.)

CMD ["java", "-jar", "app.jar"]


Default command when the container starts: run the JAR.

Equivalent to running:

java -jar app.jar


Example:
When you do:

docker run -p 8080:8080 fraud-app


You can then open http://localhost:8080
 and see your Spring Boot API running.

ğŸ”‘ Big Picture

Stage 1 builds your app (app.jar) using Maven + JDK.

Stage 2 runs it inside a minimal Alpine Linux + JRE + dockerize.

Result:

Small, fast container.

Only contains whatâ€™s needed to run the app, not to build it.

ğŸ‘‰ Do you want me to also make a visual diagram showing:

Stage 1 (big build image) â†’ produces app.jar

Stage 2 (tiny runtime image) â†’ runs app.jar

That way, youâ€™d have a picture in your head of how multi-stage builds â€œcut out the fatâ€?













-------------------------------------------------------------------------------------------------------

Exactly ğŸ‘ using the Git commit SHA as your Docker image tag is a very common and smart practice in CI/CD pipelines. Let me break it down for you:

ğŸ”¹ Why use the Git commit SHA as tag?

Uniqueness

Every commit in Git has a unique SHA (e.g., 24b8804e4f99a10e62c582b5d1f7e266fdcf76f4).

If you use this as your image tag, every build will produce a unique image. No overwriting, no confusion.

Traceability

You can trace back any Docker image to the exact commit that built it.

If something breaks in production, you know exactly which code version caused it.

Consistency across environments

Same SHA tag is used in dev, staging, prod â†’ so youâ€™re 100% sure youâ€™re running the same image everywhere.

Better caching

CI/CD can cache layers better, since image names wonâ€™t be reused incorrectly.

ğŸ”¹ Example in a Makefile

Hereâ€™s how you can do it:

IMAGE_NAME = 742460038063.dkr.ecr.eu-west-3.amazonaws.com/spring-fraud-service
GIT_SHA    = $(shell git rev-parse HEAD)

build-image:
	docker build -t $(IMAGE_NAME):$(GIT_SHA) .

push-image:
	docker push $(IMAGE_NAME):$(GIT_SHA)

build-image-push: build-image push-image

ğŸ”¹ In GitHub Actions

You can grab the SHA with github.sha:

- name: Build Docker image
  run: |
    IMAGE_NAME=742460038063.dkr.ecr.eu-west-3.amazonaws.com/spring-fraud-service
    docker build -t $IMAGE_NAME:${{ github.sha }} .
    docker push $IMAGE_NAME:${{ github.sha }}

ğŸ”¹ Bonus: â€œlatestâ€ tag

Some teams also push an extra tag like latest for convenience:

docker tag $IMAGE_NAME:${GIT_SHA} $IMAGE_NAME:latest
docker push $IMAGE_NAME:latest


This way:

latest = â€œmost recent buildâ€ (easy for dev/testing).

SHA = â€œexact commitâ€ (for production traceability).

âœ… Summary:
Using the Git commit SHA as the image tag guarantees unique, traceable, and consistent builds. Itâ€™s a best practice in pipelines.











